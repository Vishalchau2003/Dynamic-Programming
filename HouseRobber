// recursion

// class Solution {
// public:
//     int maxsum(vector<int> nums, int sum, int idx, int &maxsumi) {
//         int n = nums.size();
//         if (idx >= n) {
//             maxsumi = max(maxsumi, sum);
//             return maxsumi;
//         }

//         sum += nums[idx];
//         maxsum(nums, sum, idx + 2, maxsumi);
//         sum -= nums[idx];
//         maxsum(nums, sum, idx + 1, maxsumi);
//         return maxsumi;
//     }

//     int rob(vector<int>& nums) {
//         int maxsumi = 0;
//         return maxsum(nums, 0, 0, maxsumi);
//     }
// };

// Means: “Make a reference to the number 0.”
// But 0 is just a literal — it has no variable name or address to refer to.

/// so do   int maxsumi = 0;

// recursive
//  class Solution {
//  public:
//      int maxi(int i,vector<int>&nums){
//          int n=nums.size();

//         if(i==0) return nums[0];
//         if(i<0) return 0;//in case of negative index where we can't evev
//         reach
//         //if picked
//         int pick=nums[i]+maxi(i-2,nums);

//         //not picked
//         int notpick=maxi(i-1,nums);

//         return max(pick,notpick);

//     }
//     int rob(vector<int>& nums) {
//      int n=nums.size();
//      return maxi(n-1,nums);
//     }
// };

// memo

// class Solution {
// public:
//     int maxi(int i,vector<int>&nums,vector<int>&dp){
//         int n=nums.size();
//         if(i==0) return nums[0];
//         if(i<0) return 0;

//         if(dp[i]!=-1) return dp[i];
//         //if picked
//         int pick=nums[i]+maxi(i-2,nums,dp);

//         //not picked
//         int notpick=maxi(i-1,nums,dp);

//         return dp[i]=max(pick,notpick);

//     }
//     int rob(vector<int>& nums) {
//      int n=nums.size();
//      vector<int>dp(n,-1);
//      return maxi(n-1,nums,dp);
//     }
// };

// Tabulation

// class Solution {
// public:
//     int rob(vector<int>& nums) {
//      int n=nums.size();
//      vector<int>dp(n,-1);
//      dp[0]=nums[0];

//      for(int i=0;i<n;i++){
//         //pick
//         int pick=nums[i];//if i==1 then previous not adjacent lies at 1-2=-1
//         that is out of bound so dont add anything if(i>1) pick+=dp[i-2];
//         //not pick
//         int notpick=0+dp[i-1];

//         dp[i]=max(pick,notpick);
//      }
//      return dp[n-1];
//     }
// };

// extra memory optimization
//  class Solution {
//  public:
//      int rob(vector<int>& nums) {
//       int n=nums.size();
//       int prev=nums[0];
//       int prev2=0;
//       for(int i=0;i<n;i++){
//          //pick
//          int pick=nums[i];
//          if(i>1) pick+=prev2;
//          //not pick
//          int notpick=0+prev;
//          int curri=max(pick,notpick);

//         prev2=prev;
//         prev=curri;
//      }
//      return prev;
//     }
// };
